<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 10.0.4"/>
    <title>detector.models.utils.box_utils API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc section{margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../utils.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;detector.models.utils</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="function" href="#bbox_iou">bbox_iou</a>
            </li>
            <li>
                    <a class="function" href="#point_form">point_form</a>
            </li>
            <li>
                    <a class="function" href="#center_size">center_size</a>
            </li>
            <li>
                    <a class="function" href="#intersect">intersect</a>
            </li>
            <li>
                    <a class="function" href="#jaccard">jaccard</a>
            </li>
            <li>
                    <a class="function" href="#matrix_iou">matrix_iou</a>
            </li>
            <li>
                    <a class="function" href="#matrix_iof">matrix_iof</a>
            </li>
            <li>
                    <a class="function" href="#match">match</a>
            </li>
            <li>
                    <a class="function" href="#encode">encode</a>
            </li>
            <li>
                    <a class="function" href="#encode_landm">encode_landm</a>
            </li>
            <li>
                    <a class="function" href="#decode">decode</a>
            </li>
            <li>
                    <a class="function" href="#decode_landm">decode_landm</a>
            </li>
            <li>
                    <a class="function" href="#log_sum_exp">log_sum_exp</a>
            </li>
            <li>
                    <a class="function" href="#nms">nms</a>
            </li>
            <li>
                    <a class="function" href="#py_cpu_nms">py_cpu_nms</a>
            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../../../detector.html">detector</a><wbr>.<a href="./../../models.html">models</a><wbr>.<a href="./../utils.html">utils</a><wbr>.box_utils    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">bbox_iou</span><span class="p">(</span><span class="n">box1</span><span class="p">,</span> <span class="n">box2</span><span class="p">):</span>
    <span class="c1"># Get the coordinates of bounding boxes</span>
    <span class="n">b1_x1</span><span class="p">,</span> <span class="n">b1_y1</span><span class="p">,</span> <span class="n">b1_x2</span><span class="p">,</span> <span class="n">b1_y2</span> <span class="o">=</span> <span class="n">box1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">b2_x1</span><span class="p">,</span> <span class="n">b2_y1</span><span class="p">,</span> <span class="n">b2_x2</span><span class="p">,</span> <span class="n">b2_y2</span> <span class="o">=</span> <span class="n">box2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Intersection area</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b1_x2</span><span class="p">,</span> <span class="n">b2_x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b1_x1</span><span class="p">,</span> <span class="n">b2_x1</span><span class="p">))</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> \
            <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b1_y2</span><span class="p">,</span> <span class="n">b2_y2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b1_y1</span><span class="p">,</span> <span class="n">b2_y1</span><span class="p">))</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Union Area</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">b1_x2</span> <span class="o">-</span> <span class="n">b1_x1</span><span class="p">,</span> <span class="n">b1_y2</span> <span class="o">-</span> <span class="n">b1_y1</span>
    <span class="n">w2</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">b2_x2</span> <span class="o">-</span> <span class="n">b2_x1</span><span class="p">,</span> <span class="n">b2_y2</span> <span class="o">-</span> <span class="n">b2_y1</span>
    <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="mf">1e-16</span><span class="p">)</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">inter</span>

    <span class="n">iou</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># iou</span>

    <span class="k">return</span> <span class="n">iou</span>


<span class="k">def</span> <span class="nf">point_form</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert prior_boxes to (xmin, ymin, xmax, ymax)</span>
<span class="sd">    representation for comparison to point form ground truth data.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) center-size default boxes from priorbox layers.</span>
<span class="sd">    Return:</span>
<span class="sd">        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>     <span class="c1"># xmin, ymin</span>
                     <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># xmax, ymax</span>


<span class="k">def</span> <span class="nf">center_size</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert prior_boxes to (cx, cy, w, h)</span>
<span class="sd">    representation for comparison to center-size form ground truth data.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) point_form boxes</span>
<span class="sd">    Return:</span>
<span class="sd">        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># cx, cy</span>
                     <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># w, h</span>


<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; We resize both tensors to [A,B,2] without new malloc:</span>
<span class="sd">    [A,2] -&gt; [A,1,2] -&gt; [A,B,2]</span>
<span class="sd">    [B,2] -&gt; [1,B,2] -&gt; [A,B,2]</span>
<span class="sd">    Then we compute the area of intersect between box_a and box_b.</span>
<span class="sd">    Args:</span>
<span class="sd">      box_a: (tensor) bounding boxes, Shape: [A,4].</span>
<span class="sd">      box_b: (tensor) bounding boxes, Shape: [B,4].</span>
<span class="sd">    Return:</span>
<span class="sd">      (tensor) intersection area, Shape: [A,B].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">box_a</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">box_b</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                       <span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">min_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                       <span class="n">box_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="n">max_xy</span> <span class="o">-</span> <span class="n">min_xy</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the jaccard overlap of two sets of boxes.  The jaccard overlap</span>
<span class="sd">    is simply the intersection over union of two boxes.  Here we operate on</span>
<span class="sd">    ground truth boxes and default boxes.</span>
<span class="sd">    E.g.:</span>
<span class="sd">        A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)</span>
<span class="sd">    Args:</span>
<span class="sd">        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]</span>
<span class="sd">        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]</span>
<span class="sd">    Return:</span>
<span class="sd">        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]</span>
    <span class="n">area_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">inter</span>
    <span class="k">return</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># [A,B]</span>


<span class="k">def</span> <span class="nf">matrix_iou</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return iou of a and b, numpy version for data augenmentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>

    <span class="n">area_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">lt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">area_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_i</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">area_i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">matrix_iof</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return iof of a and b, numpy version for data augenmentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>

    <span class="n">area_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">lt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_i</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">area_a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">truths</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">landms</span><span class="p">,</span> <span class="n">loc_t</span><span class="p">,</span> <span class="n">conf_t</span><span class="p">,</span> <span class="n">landm_t</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Match each prior box with the ground truth box of the highest jaccard</span>
<span class="sd">    overlap, encode the bounding boxes, then return the matched indices</span>
<span class="sd">    corresponding to both confidence and location preds.</span>
<span class="sd">    Args:</span>
<span class="sd">        threshold: (float) The overlap threshold used when mathing boxes.</span>
<span class="sd">        truths: (tensor) Ground truth boxes, Shape: [num_obj, 4].</span>
<span class="sd">        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].</span>
<span class="sd">        variances: (tensor) Variances corresponding to each prior coord,</span>
<span class="sd">            Shape: [num_priors, 4].</span>
<span class="sd">        labels: (tensor) All the class labels for the image, Shape: [num_obj].</span>
<span class="sd">        landms: (tensor) Ground truth landms, Shape [num_obj, 10].</span>
<span class="sd">        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.</span>
<span class="sd">        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds.</span>
<span class="sd">        landm_t: (tensor) Tensor to be filled w/ endcoded landm targets.</span>
<span class="sd">        idx: (int) current batch index</span>
<span class="sd">    Return:</span>
<span class="sd">        The matched indices corresponding to 1)location 2)confidence 3)landm preds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># jaccard index</span>
    <span class="n">overlaps</span> <span class="o">=</span> <span class="n">jaccard</span><span class="p">(</span>
        <span class="n">truths</span><span class="p">,</span>
        <span class="n">point_form</span><span class="p">(</span><span class="n">priors</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># (Bipartite Matching)</span>
    <span class="c1"># [1,num_objects] best prior for each ground truth</span>
    <span class="n">best_prior_overlap</span><span class="p">,</span> <span class="n">best_prior_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ignore hard gt</span>
    <span class="n">valid_gt_idx</span> <span class="o">=</span> <span class="n">best_prior_overlap</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.2</span>
    <span class="n">best_prior_idx_filter</span> <span class="o">=</span> <span class="n">best_prior_idx</span><span class="p">[</span><span class="n">valid_gt_idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">best_prior_idx_filter</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">loc_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">conf_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span>

    <span class="c1"># [1,num_priors] best ground truth for each prior</span>
    <span class="n">best_truth_overlap</span><span class="p">,</span> <span class="n">best_truth_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">best_truth_idx</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">best_truth_overlap</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">best_prior_idx</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_prior_idx_filter</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_prior_overlap</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_truth_overlap</span><span class="o">.</span><span class="n">index_fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_prior_idx_filter</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># ensure best prior</span>
    <span class="c1"># TODO refactor: index  best_prior_idx with long tensor</span>
    <span class="c1"># ensure every gt matches with its prior of max overlap</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">best_prior_idx</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>     <span class="c1"># 判别此anchor是预测哪一个boxes</span>
        <span class="n">best_truth_idx</span><span class="p">[</span><span class="n">best_prior_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">truths</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>            <span class="c1"># Shape: [num_priors,4] 此处为每一个anchor对应的bbox取出来</span>
    <span class="n">conf</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>               <span class="c1"># Shape: [num_priors]      此处为每一个anchor对应的label取出来</span>
    <span class="n">conf</span><span class="p">[</span><span class="n">best_truth_overlap</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># label as background   overlap&lt;0.35的全部作为负样本</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>

    <span class="n">matches_landm</span> <span class="o">=</span> <span class="n">landms</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>
    <span class="n">landm</span> <span class="o">=</span> <span class="n">encode_landm</span><span class="p">(</span><span class="n">matches_landm</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>
    <span class="n">loc_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>    <span class="c1"># [num_priors,4] encoded offsets to learn</span>
    <span class="n">conf_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">conf</span>  <span class="c1"># [num_priors] top class label for each prior</span>
    <span class="n">landm_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">landm</span>


<span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encode the variances from the priorbox layers into the ground truth boxes</span>
<span class="sd">    we have matched (based on jaccard overlap) with the prior boxes.</span>
<span class="sd">    Args:</span>
<span class="sd">        matched: (tensor) Coords of ground truth for each prior in point-form</span>
<span class="sd">            Shape: [num_priors, 4].</span>
<span class="sd">        priors: (tensor) Prior boxes in center-offset form</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        encoded boxes (tensor), Shape: [num_priors, 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dist b/t match center and prior&#39;s center</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># encode variance</span>
    <span class="n">g_cxcy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>
    <span class="c1"># match wh / prior wh</span>
    <span class="n">g_wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span>
    <span class="n">g_wh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g_wh</span><span class="p">)</span> <span class="o">/</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># return target for smooth_l1_loss</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">g_cxcy</span><span class="p">,</span> <span class="n">g_wh</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [num_priors,4]</span>


<span class="k">def</span> <span class="nf">encode_landm</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encode the variances from the priorbox layers into the ground truth boxes</span>
<span class="sd">    we have matched (based on jaccard overlap) with the prior boxes.</span>
<span class="sd">    Args:</span>
<span class="sd">        matched: (tensor) Coords of ground truth for each prior in point-form</span>
<span class="sd">            Shape: [num_priors, 10].</span>
<span class="sd">        priors: (tensor) Prior boxes in center-offset form</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        encoded landm (tensor), Shape: [num_priors, 10]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dist b/t match center and prior&#39;s center</span>
    <span class="n">matched</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">priors_cx</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_cy</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_w</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_h</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">priors_cx</span><span class="p">,</span> <span class="n">priors_cy</span><span class="p">,</span> <span class="n">priors_w</span><span class="p">,</span> <span class="n">priors_h</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="n">matched</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># encode variance</span>
    <span class="n">g_cxcy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:])</span>
    <span class="c1"># g_cxcy /= priors[:, :, 2:]</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="n">g_cxcy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">g_cxcy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># return target for smooth_l1_loss</span>
    <span class="k">return</span> <span class="n">g_cxcy</span>


<span class="c1"># Adapted from https://github.com/Hakuyume/chainer-ssd</span>
<span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode locations from predictions using priors to undo</span>
<span class="sd">    the encoding we did for offset regression at train time.</span>
<span class="sd">    Args:</span>
<span class="sd">        loc (tensor): location predictions for loc layers,</span>
<span class="sd">            Shape: [num_priors,4]</span>
<span class="sd">        priors (tensor): Prior boxes in center-offset form.</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        decoded bounding box predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">boxes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span>
        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">loc</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
        <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">boxes</span>


<span class="k">def</span> <span class="nf">decode_landm</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode landm from predictions using priors to undo</span>
<span class="sd">    the encoding we did for offset regression at train time.</span>
<span class="sd">    Args:</span>
<span class="sd">        pre (tensor): landm predictions for loc layers,</span>
<span class="sd">            Shape: [num_priors,10]</span>
<span class="sd">        priors (tensor): Prior boxes in center-offset form.</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        decoded landm predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">landms</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">landms</span>


<span class="k">def</span> <span class="nf">log_sum_exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utility function for computing log_sum_exp while determining</span>
<span class="sd">    This will be used to determine unaveraged confidence loss across</span>
<span class="sd">    all examples in a batch.</span>
<span class="sd">    Args:</span>
<span class="sd">        x (Variable(tensor)): conf_preds from conf layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">+</span> <span class="n">x_max</span>


<span class="c1"># Original author: Francisco Massa:</span>
<span class="c1"># https://github.com/fmassa/object-detection.torch</span>
<span class="c1"># Ported to PyTorch by Max deGroot (02/01/2017)</span>
<span class="k">def</span> <span class="nf">nms</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">top_k</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply non-maximum suppression at test time to avoid detecting too many</span>
<span class="sd">    overlapping bounding boxes for a given object.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) The location preds for the img, Shape: [num_priors,4].</span>
<span class="sd">        scores: (tensor) The class predscores for the img, Shape:[num_priors].</span>
<span class="sd">        overlap: (float) The overlap thresh for suppressing unnecessary boxes.</span>
<span class="sd">        top_k: (int) The Maximum number of box preds to consider.</span>
<span class="sd">    Return:</span>
<span class="sd">        The indices of the kept boxes with respect to num_priors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">boxes</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">keep</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sort in ascending order</span>
    <span class="c1"># I = I[v &gt;= 0.01]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="n">top_k</span><span class="p">:]</span>  <span class="c1"># indices of the top-k largest vals</span>
    <span class="n">xx1</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">yy1</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">xx2</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">yy2</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

    <span class="c1"># keep = torch.Tensor()</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># index of current largest val</span>
        <span class="c1"># keep.append(i)</span>
        <span class="n">keep</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove kept element from view</span>
        <span class="c1"># load bboxes of next highest vals</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx1</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy1</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy2</span><span class="p">)</span>
        <span class="c1"># store element-wise max with next highest score</span>
        <span class="n">xx1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">xx1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">yy1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">yy1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">yy2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">yy2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">w</span><span class="o">.</span><span class="n">resize_as_</span><span class="p">(</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">resize_as_</span><span class="p">(</span><span class="n">yy2</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span>
        <span class="c1"># check sizes of xx1 and xx2.. after each iteration</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">h</span>
        <span class="c1"># IoU = i / (area(a) + area(b) - i)</span>
        <span class="n">rem_areas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># load remaining areas)</span>
        <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem_areas</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span> <span class="o">+</span> <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">IoU</span> <span class="o">=</span> <span class="n">inter</span><span class="o">/</span><span class="n">union</span>  <span class="c1"># store result in iou</span>
        <span class="c1"># keep only elements with an IoU &lt;= overlap</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">IoU</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">overlap</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">keep</span><span class="p">,</span> <span class="n">count</span>


<span class="k">def</span> <span class="nf">py_cpu_nms</span><span class="p">(</span><span class="n">dets</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure Python NMS baseline.&quot;&quot;&quot;</span>

    <span class="c1"># --------------------------------------------------------</span>
    <span class="c1"># Fast R-CNN</span>
    <span class="c1"># Copyright (c) 2015 Microsoft</span>
    <span class="c1"># Licensed under The MIT License [see LICENSE for details]</span>
    <span class="c1"># Written by Ross Girshick</span>
    <span class="c1"># --------------------------------------------------------</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>

    <span class="n">areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">order</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">xx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span>
        <span class="n">ovr</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="p">(</span><span class="n">areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">areas</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ovr</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">keep</span>
</pre></div>

        </details>

            </section>
                <section id="bbox_iou">
                            <div class="attr function"><a class="headerlink" href="#bbox_iou">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">bbox_iou</span><span class="signature">(box1, box2)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">bbox_iou</span><span class="p">(</span><span class="n">box1</span><span class="p">,</span> <span class="n">box2</span><span class="p">):</span>
    <span class="c1"># Get the coordinates of bounding boxes</span>
    <span class="n">b1_x1</span><span class="p">,</span> <span class="n">b1_y1</span><span class="p">,</span> <span class="n">b1_x2</span><span class="p">,</span> <span class="n">b1_y2</span> <span class="o">=</span> <span class="n">box1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">b2_x1</span><span class="p">,</span> <span class="n">b2_y1</span><span class="p">,</span> <span class="n">b2_x2</span><span class="p">,</span> <span class="n">b2_y2</span> <span class="o">=</span> <span class="n">box2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Intersection area</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b1_x2</span><span class="p">,</span> <span class="n">b2_x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b1_x1</span><span class="p">,</span> <span class="n">b2_x1</span><span class="p">))</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> \
            <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b1_y2</span><span class="p">,</span> <span class="n">b2_y2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b1_y1</span><span class="p">,</span> <span class="n">b2_y1</span><span class="p">))</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Union Area</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">b1_x2</span> <span class="o">-</span> <span class="n">b1_x1</span><span class="p">,</span> <span class="n">b1_y2</span> <span class="o">-</span> <span class="n">b1_y1</span>
    <span class="n">w2</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">b2_x2</span> <span class="o">-</span> <span class="n">b2_x1</span><span class="p">,</span> <span class="n">b2_y2</span> <span class="o">-</span> <span class="n">b2_y1</span>
    <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="mf">1e-16</span><span class="p">)</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">inter</span>

    <span class="n">iou</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># iou</span>

    <span class="k">return</span> <span class="n">iou</span>
</pre></div>

        </details>

    

                </section>
                <section id="point_form">
                            <div class="attr function"><a class="headerlink" href="#point_form">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">point_form</span><span class="signature">(boxes)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">point_form</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert prior_boxes to (xmin, ymin, xmax, ymax)</span>
<span class="sd">    representation for comparison to point form ground truth data.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) center-size default boxes from priorbox layers.</span>
<span class="sd">    Return:</span>
<span class="sd">        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>     <span class="c1"># xmin, ymin</span>
                     <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># xmax, ymax</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convert prior_boxes to (xmin, ymin, xmax, ymax)
representation for comparison to point form ground truth data.
Args:
    boxes: (tensor) center-size default boxes from priorbox layers.
Return:
    boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</p>
</div>


                </section>
                <section id="center_size">
                            <div class="attr function"><a class="headerlink" href="#center_size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">center_size</span><span class="signature">(boxes)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">center_size</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert prior_boxes to (cx, cy, w, h)</span>
<span class="sd">    representation for comparison to center-size form ground truth data.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) point_form boxes</span>
<span class="sd">    Return:</span>
<span class="sd">        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># cx, cy</span>
                     <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># w, h</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convert prior_boxes to (cx, cy, w, h)
representation for comparison to center-size form ground truth data.
Args:
    boxes: (tensor) point_form boxes
Return:
    boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.</p>
</div>


                </section>
                <section id="intersect">
                            <div class="attr function"><a class="headerlink" href="#intersect">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">intersect</span><span class="signature">(box_a, box_b)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; We resize both tensors to [A,B,2] without new malloc:</span>
<span class="sd">    [A,2] -&gt; [A,1,2] -&gt; [A,B,2]</span>
<span class="sd">    [B,2] -&gt; [1,B,2] -&gt; [A,B,2]</span>
<span class="sd">    Then we compute the area of intersect between box_a and box_b.</span>
<span class="sd">    Args:</span>
<span class="sd">      box_a: (tensor) bounding boxes, Shape: [A,4].</span>
<span class="sd">      box_b: (tensor) bounding boxes, Shape: [B,4].</span>
<span class="sd">    Return:</span>
<span class="sd">      (tensor) intersection area, Shape: [A,B].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">box_a</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">box_b</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                       <span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">min_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                       <span class="n">box_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="n">max_xy</span> <span class="o">-</span> <span class="n">min_xy</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>We resize both tensors to [A,B,2] without new malloc:
[A,2] -> [A,1,2] -> [A,B,2]
[B,2] -> [1,B,2] -> [A,B,2]
Then we compute the area of intersect between box_a and box_b.
Args:
  box_a: (tensor) bounding boxes, Shape: [A,4].
  box_b: (tensor) bounding boxes, Shape: [B,4].
Return:
  (tensor) intersection area, Shape: [A,B].</p>
</div>


                </section>
                <section id="jaccard">
                            <div class="attr function"><a class="headerlink" href="#jaccard">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">jaccard</span><span class="signature">(box_a, box_b)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the jaccard overlap of two sets of boxes.  The jaccard overlap</span>
<span class="sd">    is simply the intersection over union of two boxes.  Here we operate on</span>
<span class="sd">    ground truth boxes and default boxes.</span>
<span class="sd">    E.g.:</span>
<span class="sd">        A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)</span>
<span class="sd">    Args:</span>
<span class="sd">        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]</span>
<span class="sd">        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]</span>
<span class="sd">    Return:</span>
<span class="sd">        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]</span>
    <span class="n">area_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]</span>
    <span class="n">union</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">inter</span>
    <span class="k">return</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># [A,B]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the jaccard overlap of two sets of boxes.  The jaccard overlap
is simply the intersection over union of two boxes.  Here we operate on
ground truth boxes and default boxes.
E.g.:
    A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)
Args:
    box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]
    box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]
Return:
    jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]</p>
</div>


                </section>
                <section id="matrix_iou">
                            <div class="attr function"><a class="headerlink" href="#matrix_iou">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">matrix_iou</span><span class="signature">(a, b)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">matrix_iou</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return iou of a and b, numpy version for data augenmentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>

    <span class="n">area_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">lt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">area_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_i</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">area_i</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>return iou of a and b, numpy version for data augenmentation</p>
</div>


                </section>
                <section id="matrix_iof">
                            <div class="attr function"><a class="headerlink" href="#matrix_iof">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">matrix_iof</span><span class="signature">(a, b)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">matrix_iof</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return iof of a and b, numpy version for data augenmentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>

    <span class="n">area_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rb</span> <span class="o">-</span> <span class="n">lt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_i</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">area_a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>return iof of a and b, numpy version for data augenmentation</p>
</div>


                </section>
                <section id="match">
                            <div class="attr function"><a class="headerlink" href="#match">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">match</span><span class="signature">(
    threshold,
    truths,
    priors,
    variances,
    labels,
    landms,
    loc_t,
    conf_t,
    landm_t,
    idx
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">truths</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">landms</span><span class="p">,</span> <span class="n">loc_t</span><span class="p">,</span> <span class="n">conf_t</span><span class="p">,</span> <span class="n">landm_t</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Match each prior box with the ground truth box of the highest jaccard</span>
<span class="sd">    overlap, encode the bounding boxes, then return the matched indices</span>
<span class="sd">    corresponding to both confidence and location preds.</span>
<span class="sd">    Args:</span>
<span class="sd">        threshold: (float) The overlap threshold used when mathing boxes.</span>
<span class="sd">        truths: (tensor) Ground truth boxes, Shape: [num_obj, 4].</span>
<span class="sd">        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].</span>
<span class="sd">        variances: (tensor) Variances corresponding to each prior coord,</span>
<span class="sd">            Shape: [num_priors, 4].</span>
<span class="sd">        labels: (tensor) All the class labels for the image, Shape: [num_obj].</span>
<span class="sd">        landms: (tensor) Ground truth landms, Shape [num_obj, 10].</span>
<span class="sd">        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.</span>
<span class="sd">        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds.</span>
<span class="sd">        landm_t: (tensor) Tensor to be filled w/ endcoded landm targets.</span>
<span class="sd">        idx: (int) current batch index</span>
<span class="sd">    Return:</span>
<span class="sd">        The matched indices corresponding to 1)location 2)confidence 3)landm preds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># jaccard index</span>
    <span class="n">overlaps</span> <span class="o">=</span> <span class="n">jaccard</span><span class="p">(</span>
        <span class="n">truths</span><span class="p">,</span>
        <span class="n">point_form</span><span class="p">(</span><span class="n">priors</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># (Bipartite Matching)</span>
    <span class="c1"># [1,num_objects] best prior for each ground truth</span>
    <span class="n">best_prior_overlap</span><span class="p">,</span> <span class="n">best_prior_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ignore hard gt</span>
    <span class="n">valid_gt_idx</span> <span class="o">=</span> <span class="n">best_prior_overlap</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.2</span>
    <span class="n">best_prior_idx_filter</span> <span class="o">=</span> <span class="n">best_prior_idx</span><span class="p">[</span><span class="n">valid_gt_idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">best_prior_idx_filter</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">loc_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">conf_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span>

    <span class="c1"># [1,num_priors] best ground truth for each prior</span>
    <span class="n">best_truth_overlap</span><span class="p">,</span> <span class="n">best_truth_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">best_truth_idx</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">best_truth_overlap</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">best_prior_idx</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_prior_idx_filter</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_prior_overlap</span><span class="o">.</span><span class="n">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">best_truth_overlap</span><span class="o">.</span><span class="n">index_fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_prior_idx_filter</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># ensure best prior</span>
    <span class="c1"># TODO refactor: index  best_prior_idx with long tensor</span>
    <span class="c1"># ensure every gt matches with its prior of max overlap</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">best_prior_idx</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>     <span class="c1"># 判别此anchor是预测哪一个boxes</span>
        <span class="n">best_truth_idx</span><span class="p">[</span><span class="n">best_prior_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">truths</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>            <span class="c1"># Shape: [num_priors,4] 此处为每一个anchor对应的bbox取出来</span>
    <span class="n">conf</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>               <span class="c1"># Shape: [num_priors]      此处为每一个anchor对应的label取出来</span>
    <span class="n">conf</span><span class="p">[</span><span class="n">best_truth_overlap</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># label as background   overlap&lt;0.35的全部作为负样本</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>

    <span class="n">matches_landm</span> <span class="o">=</span> <span class="n">landms</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>
    <span class="n">landm</span> <span class="o">=</span> <span class="n">encode_landm</span><span class="p">(</span><span class="n">matches_landm</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>
    <span class="n">loc_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>    <span class="c1"># [num_priors,4] encoded offsets to learn</span>
    <span class="n">conf_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">conf</span>  <span class="c1"># [num_priors] top class label for each prior</span>
    <span class="n">landm_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">landm</span>
</pre></div>

        </details>

            <div class="docstring"><p>Match each prior box with the ground truth box of the highest jaccard
overlap, encode the bounding boxes, then return the matched indices
corresponding to both confidence and location preds.
Args:
    threshold: (float) The overlap threshold used when mathing boxes.
    truths: (tensor) Ground truth boxes, Shape: [num_obj, 4].
    priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].
    variances: (tensor) Variances corresponding to each prior coord,
        Shape: [num_priors, 4].
    labels: (tensor) All the class labels for the image, Shape: [num_obj].
    landms: (tensor) Ground truth landms, Shape [num_obj, 10].
    loc_t: (tensor) Tensor to be filled w/ endcoded location targets.
    conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds.
    landm_t: (tensor) Tensor to be filled w/ endcoded landm targets.
    idx: (int) current batch index
Return:
    The matched indices corresponding to 1)location 2)confidence 3)landm preds.</p>
</div>


                </section>
                <section id="encode">
                            <div class="attr function"><a class="headerlink" href="#encode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">encode</span><span class="signature">(matched, priors, variances)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encode the variances from the priorbox layers into the ground truth boxes</span>
<span class="sd">    we have matched (based on jaccard overlap) with the prior boxes.</span>
<span class="sd">    Args:</span>
<span class="sd">        matched: (tensor) Coords of ground truth for each prior in point-form</span>
<span class="sd">            Shape: [num_priors, 4].</span>
<span class="sd">        priors: (tensor) Prior boxes in center-offset form</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        encoded boxes (tensor), Shape: [num_priors, 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dist b/t match center and prior&#39;s center</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># encode variance</span>
    <span class="n">g_cxcy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>
    <span class="c1"># match wh / prior wh</span>
    <span class="n">g_wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span>
    <span class="n">g_wh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g_wh</span><span class="p">)</span> <span class="o">/</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># return target for smooth_l1_loss</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">g_cxcy</span><span class="p">,</span> <span class="n">g_wh</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [num_priors,4]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Encode the variances from the priorbox layers into the ground truth boxes
we have matched (based on jaccard overlap) with the prior boxes.
Args:
    matched: (tensor) Coords of ground truth for each prior in point-form
        Shape: [num_priors, 4].
    priors: (tensor) Prior boxes in center-offset form
        Shape: [num_priors,4].
    variances: (list[float]) Variances of priorboxes
Return:
    encoded boxes (tensor), Shape: [num_priors, 4]</p>
</div>


                </section>
                <section id="encode_landm">
                            <div class="attr function"><a class="headerlink" href="#encode_landm">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">encode_landm</span><span class="signature">(matched, priors, variances)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">encode_landm</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encode the variances from the priorbox layers into the ground truth boxes</span>
<span class="sd">    we have matched (based on jaccard overlap) with the prior boxes.</span>
<span class="sd">    Args:</span>
<span class="sd">        matched: (tensor) Coords of ground truth for each prior in point-form</span>
<span class="sd">            Shape: [num_priors, 10].</span>
<span class="sd">        priors: (tensor) Prior boxes in center-offset form</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        encoded landm (tensor), Shape: [num_priors, 10]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dist b/t match center and prior&#39;s center</span>
    <span class="n">matched</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">priors_cx</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_cy</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_w</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors_h</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">priors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">priors_cx</span><span class="p">,</span> <span class="n">priors_cy</span><span class="p">,</span> <span class="n">priors_w</span><span class="p">,</span> <span class="n">priors_h</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="n">matched</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># encode variance</span>
    <span class="n">g_cxcy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:])</span>
    <span class="c1"># g_cxcy /= priors[:, :, 2:]</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="n">g_cxcy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">g_cxcy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># return target for smooth_l1_loss</span>
    <span class="k">return</span> <span class="n">g_cxcy</span>
</pre></div>

        </details>

            <div class="docstring"><p>Encode the variances from the priorbox layers into the ground truth boxes
we have matched (based on jaccard overlap) with the prior boxes.
Args:
    matched: (tensor) Coords of ground truth for each prior in point-form
        Shape: [num_priors, 10].
    priors: (tensor) Prior boxes in center-offset form
        Shape: [num_priors,4].
    variances: (list[float]) Variances of priorboxes
Return:
    encoded landm (tensor), Shape: [num_priors, 10]</p>
</div>


                </section>
                <section id="decode">
                            <div class="attr function"><a class="headerlink" href="#decode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">decode</span><span class="signature">(loc, priors, variances)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode locations from predictions using priors to undo</span>
<span class="sd">    the encoding we did for offset regression at train time.</span>
<span class="sd">    Args:</span>
<span class="sd">        loc (tensor): location predictions for loc layers,</span>
<span class="sd">            Shape: [num_priors,4]</span>
<span class="sd">        priors (tensor): Prior boxes in center-offset form.</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        decoded bounding box predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">boxes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span>
        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">loc</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
        <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">boxes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decode locations from predictions using priors to undo
the encoding we did for offset regression at train time.
Args:
    loc (tensor): location predictions for loc layers,
        Shape: [num_priors,4]
    priors (tensor): Prior boxes in center-offset form.
        Shape: [num_priors,4].
    variances: (list[float]) Variances of priorboxes
Return:
    decoded bounding box predictions</p>
</div>


                </section>
                <section id="decode_landm">
                            <div class="attr function"><a class="headerlink" href="#decode_landm">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">decode_landm</span><span class="signature">(pre, priors, variances)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">decode_landm</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode landm from predictions using priors to undo</span>
<span class="sd">    the encoding we did for offset regression at train time.</span>
<span class="sd">    Args:</span>
<span class="sd">        pre (tensor): landm predictions for loc layers,</span>
<span class="sd">            Shape: [num_priors,10]</span>
<span class="sd">        priors (tensor): Prior boxes in center-offset form.</span>
<span class="sd">            Shape: [num_priors,4].</span>
<span class="sd">        variances: (list[float]) Variances of priorboxes</span>
<span class="sd">    Return:</span>
<span class="sd">        decoded landm predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">landms</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">[:,</span> <span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span>
                        <span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">landms</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decode landm from predictions using priors to undo
the encoding we did for offset regression at train time.
Args:
    pre (tensor): landm predictions for loc layers,
        Shape: [num_priors,10]
    priors (tensor): Prior boxes in center-offset form.
        Shape: [num_priors,4].
    variances: (list[float]) Variances of priorboxes
Return:
    decoded landm predictions</p>
</div>


                </section>
                <section id="log_sum_exp">
                            <div class="attr function"><a class="headerlink" href="#log_sum_exp">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">log_sum_exp</span><span class="signature">(x)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">log_sum_exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utility function for computing log_sum_exp while determining</span>
<span class="sd">    This will be used to determine unaveraged confidence loss across</span>
<span class="sd">    all examples in a batch.</span>
<span class="sd">    Args:</span>
<span class="sd">        x (Variable(tensor)): conf_preds from conf layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">+</span> <span class="n">x_max</span>
</pre></div>

        </details>

            <div class="docstring"><p>Utility function for computing log_sum_exp while determining
This will be used to determine unaveraged confidence loss across
all examples in a batch.
Args:
    x (Variable(tensor)): conf_preds from conf layers</p>
</div>


                </section>
                <section id="nms">
                            <div class="attr function"><a class="headerlink" href="#nms">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">nms</span><span class="signature">(boxes, scores, overlap=0.5, top_k=200)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">nms</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">top_k</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply non-maximum suppression at test time to avoid detecting too many</span>
<span class="sd">    overlapping bounding boxes for a given object.</span>
<span class="sd">    Args:</span>
<span class="sd">        boxes: (tensor) The location preds for the img, Shape: [num_priors,4].</span>
<span class="sd">        scores: (tensor) The class predscores for the img, Shape:[num_priors].</span>
<span class="sd">        overlap: (float) The overlap thresh for suppressing unnecessary boxes.</span>
<span class="sd">        top_k: (int) The Maximum number of box preds to consider.</span>
<span class="sd">    Return:</span>
<span class="sd">        The indices of the kept boxes with respect to num_priors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">boxes</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">keep</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sort in ascending order</span>
    <span class="c1"># I = I[v &gt;= 0.01]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="n">top_k</span><span class="p">:]</span>  <span class="c1"># indices of the top-k largest vals</span>
    <span class="n">xx1</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">yy1</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">xx2</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">yy2</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

    <span class="c1"># keep = torch.Tensor()</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># index of current largest val</span>
        <span class="c1"># keep.append(i)</span>
        <span class="n">keep</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove kept element from view</span>
        <span class="c1"># load bboxes of next highest vals</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx1</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy1</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy2</span><span class="p">)</span>
        <span class="c1"># store element-wise max with next highest score</span>
        <span class="n">xx1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">xx1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">yy1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">yy1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">yy2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">yy2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">w</span><span class="o">.</span><span class="n">resize_as_</span><span class="p">(</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">resize_as_</span><span class="p">(</span><span class="n">yy2</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span>
        <span class="c1"># check sizes of xx1 and xx2.. after each iteration</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">h</span>
        <span class="c1"># IoU = i / (area(a) + area(b) - i)</span>
        <span class="n">rem_areas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># load remaining areas)</span>
        <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem_areas</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span> <span class="o">+</span> <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">IoU</span> <span class="o">=</span> <span class="n">inter</span><span class="o">/</span><span class="n">union</span>  <span class="c1"># store result in iou</span>
        <span class="c1"># keep only elements with an IoU &lt;= overlap</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">IoU</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">overlap</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">keep</span><span class="p">,</span> <span class="n">count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Apply non-maximum suppression at test time to avoid detecting too many
overlapping bounding boxes for a given object.
Args:
    boxes: (tensor) The location preds for the img, Shape: [num_priors,4].
    scores: (tensor) The class predscores for the img, Shape:[num_priors].
    overlap: (float) The overlap thresh for suppressing unnecessary boxes.
    top_k: (int) The Maximum number of box preds to consider.
Return:
    The indices of the kept boxes with respect to num_priors.</p>
</div>


                </section>
                <section id="py_cpu_nms">
                            <div class="attr function"><a class="headerlink" href="#py_cpu_nms">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">py_cpu_nms</span><span class="signature">(dets, thresh)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">py_cpu_nms</span><span class="p">(</span><span class="n">dets</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure Python NMS baseline.&quot;&quot;&quot;</span>

    <span class="c1"># --------------------------------------------------------</span>
    <span class="c1"># Fast R-CNN</span>
    <span class="c1"># Copyright (c) 2015 Microsoft</span>
    <span class="c1"># Licensed under The MIT License [see LICENSE for details]</span>
    <span class="c1"># Written by Ross Girshick</span>
    <span class="c1"># --------------------------------------------------------</span>

    <span class="n">x1</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">dets</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>

    <span class="n">areas</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">order</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">xx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">yy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span>
        <span class="n">ovr</span> <span class="o">=</span> <span class="n">inter</span> <span class="o">/</span> <span class="p">(</span><span class="n">areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">areas</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ovr</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">keep</span>
</pre></div>

        </details>

            <div class="docstring"><p>Pure Python NMS baseline.</p>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>